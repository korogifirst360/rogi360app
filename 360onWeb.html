<!--
/**
 * 360 Image DEEP HACK 360onWeb - Enhanced with Exponential Effect + Image Rotate (2D)
 * 
 * @description 360イメージを編集するWebアプリケーション（指数関数効果付き + 画像の2D回転）
 * @author いけだじゅんじ (enhanced by Claude, updated by ChatGPT)
 * @version 1k edit1k save4k Clear D&D XYmove + Exponential Effect + ImageRotate2D (Order: Effects → Shift → 2D Rotate)
 * @date 20250812 
 * @license Public Domain - 再配布、改変自由、一切の制限なし
 * @disclaimer 
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 *   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DAMAGES ARISING FROM THE USE OF THIS SOFTWARE.
 *   このソフトウェアは無保証で提供され、作者は一切の責任を負いません。
 *   - メモリ不足によるブラウザクラッシュの可能性があります
 *   - 処理結果の品質は保証されません
 *   - 重要なデータは事前にバックアップしてください
 *   - 本ソフトウェアの使用は自己責任でお願いします
 */
-->

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360onWeb</title>
    <style>
    
        :root {
                /* 全体の背景色の指定 */
            --bg-gradient-start: #1e3c72;   /* 青#1e3c72 紫#3d1a78 橙#cc5500 緑#2d5016*/
            --bg-gradient-end: #2a5298;     /* 青#2a5298 紫#7209b7 橙#ff8c42 緑#4a7c59*/
            
                /* スライダーの背景グラデーションの指定 */    
            --slider-grdnt-start: #4CAF50;  /* #4CAF50 */
            --slider-grdnt-end: #2196F3;    /* #2196F3 */
            
                /* 上部エリアの指定 */    
            --upload-area-border--: 3px dashed #4CAF50;     /* 3px dashed #4CAF50 */
            --upload-area-bg--: rgba(255,255,255,0.1);      /*  rgba(255,255,255,0.15) */
            --upload-hover-border--: #45a049;               /* #45a049 */
            --upload-hover-bg--: rgba(255,255,255,0.15);    /*  rgba(255,255,255,0.15) */
            --upload-dragover-border--: #2196F3;            /* #2196F3 */
            --upload-dragover-bg--: rgba(33,150,243,0.2);   /* rgba(33,150,243,0.2) */
            
                 /* 上部読み込みボタンの指定 */
            --upload-btn--: #4CAF50;        /* #4CAF50 */
            --upload-btn-hover--: #45a049;  /* #45a049 */
            
                 /* 下部保存・共有ボタンの指定 */    
            --download-btn-bg--: linear-gradient(45deg, #667eea, #764ba2);  /* linear-gradient(45deg, #667eea, #764ba2) */
            --download-btn-hover--: rgba(0,0,0,0.3);                        /* rgba(0,0,0,0.3) */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));/* style直後 :rootで指定 */
            color: white;
            min-height: 100vh;
        }
    
        .container {
            max-width: 1524px;// max 1200 20250808
            margin: 0 auto;
        }
    
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }
            /* for guidelines */
        .upload-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: nowrap;
        }
    
        /* for guidelines 20250811+ */
        .app-title {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .upload-area {
            border: var(--upload-area-border--);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            background: var(--upload-area-bg--);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
    
        .upload-area:hover {
            border-color: var(--upload-hover-border--);
            background: var(--upload-hover-bg--);        }
    
        .upload-area.dragover {
            border-color: var(--upload-dragover-border--);
            background: var(--upload-dragover-bg--);
        }
    
        input[type="file"] {
            display: none;
        }
    
        .upload-btn {
            background: var(--upload-btn--);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;/* for guidelines 20250811+ */
        }
    
        .upload-btn:hover {
            background: var(--upload-btn-hover--);
        }
    
        .main-content { /* 起動時はコントロール群を表示しない！ */
            display: none;
        }
    
        .editor-container { /* 編集表示領域とコントロール群との間隔 */
            display: flex; /* 後半コードで縦向き用CSSで上書き有り、よって横向き用 */
            gap: 30px;
            align-items: flex-start;
        }
    
        .canvas-container {
            flex: 1;
            text-align: center;
        }
    
        .canvas-wrapper {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
            touch-action: none;
            cursor: grab;
        }
    
        canvas:active {
            cursor: grabbing;
        }
    
        .controls {
            width: 300px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        .control-group {
            margin-bottom: 18px;
        }
    
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #f0f0f0;
        }
    
        .label-text {
            text-align: left;
        }
    
        .value-display {
            font-size: 14px;
            color: #ddd;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    
        .value-display:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
    
        .value-input {
            font-size: 14px;
            color: white;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 2px 6px;
            outline: none;
        }
    
        .slider-container {
            position: relative;
        }
    
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--slider-grdnt-start), var(--slider-grdnt-end));
            outline: none;
            -webkit-appearance: none;
        }
    
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        .download-btn {
            width: 100%;
            background: var(--download-btn-bg--);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
    
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--download-btn-hover--);
        }
    
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
    
        .loading-content {
            text-align: center;
            color: white;
            font-size: 18px;
        }
    
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        .touch-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
    
        /* 縦向き（ポートレート）のレイアウト */
        @media screen and (orientation: portrait) {
            .container { /* for main window */
                display: flex;
                flex-direction: column;
                width: 100%;
                margin: 0 auto;
            }
            
            .upload-area {
                width: 100% !important;
                margin-bottom: 20px;
                box-sizing: border-box;
            }
            
            .editor-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .canvas-container {
                width: 100% !important;
                box-sizing: border-box;
            }
            
            .controls {
                width: 100% !important;
                margin: 0;
                box-sizing: border-box;
            }
            
            .canvas-wrapper {
                padding: 15px;
                box-sizing: border-box;
            }
            
            .controls {
                padding: 20px;
                box-sizing: border-box;
            }
        }
    
        /* 横向き（ランドスケープ）のレイアウト */
        @media screen and (orientation: landscape) {
            .container { /* for main window */
                display: flex;
                flex-direction: column;
            }
            
            .upload-area {
                width: 96%;// 100% 20250808
                margin-bottom: 20px;
                order: -1;
            }
            
            .editor-container {
                display: flex;
                flex-direction: row;
                gap: 20px;
            }
            
            .canvas-container {
                flex: 1;
                width: 50%;
            }
            
            .controls {
                flex: 1;
                width: 50%;
                margin: 0;
            }
        }
    
        /* 小さな画面での調整 */
        @media (max-width: 768px) {
            .editor-container {
                gap: 10px;
            }
            
            .canvas-wrapper {
                padding: 15px;
            }
            
            .controls {
                padding: 20px;
            }
        }
        
        
        
        /* 構図ガイドライン選択メニューのスタイル 20250811+ */
        .guideline-menu {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .guideline-menu label {
            color: white;
            font-size: 14px;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .guideline-menu select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .guideline-menu select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-menu select option {
            background: #333;
            color: white;
        }
                
        .guideline-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 120px;
            flex-shrink: 0;
        }
        
        .guideline-select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-select option {
            background: #333;
            color: white;
        }
            
            

    </style>
</head>
<body>
    <div class="container"> <!-- main window- -->
        <!-- ① ドラッグ＆ドロップエリア -->
        <div class="upload-area" id="uploadArea">  <!-- drag & drop area--- -->
            <div class="upload-header">
                <span class="app-title">360onWeb</span>
                <button class="upload-btn" onclick="resetControlsAndSelectFile()">
                    🖼️ +360
                </button>
                <select id="guidelineSelect" class="guideline-select">
                    <option value="none">ガイドなし</option>
                    <option value="line01">三分割</option>
                    <option value="line02">六分割</option>
                    <option value="line03">同心円</option>
                    <option value="line04">円分割</option>
                    <option value="line05">フィボナッチ</option>
                    <option value="line06">Sカーブ</option>
                </select>
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>  <!-- ---drag & drop area -->

        <div class="main-content" id="mainContent">  <!-- controlls 起動時非表示--- -->
            <div class="editor-container"> <!-- 縦長・横長・小サイズの設定--- -->
                <div class="canvas-container"> <!-- 表示とタッチ--- -->
                    <div class="canvas-wrapper">
                        <canvas id="canvas" width="720" height="720">　<!-- 720 x 720 表示サイズ -->
                    
                        </canvas>    
                                             
                        <div class="touch-indicator" id="touchIndicator">
                        Move Center</div>
                    </div>
                </div> <!-- ---表示とタッチ -->
                <div class="controls">  <!-- ??? inner --- -->
                    <div class="control-group"> <!-- スライダー 1 -->
                        <div class="control-label">
                            <span class="label-text">🔍 Zoom 拡大縮小</span>
                            <input type="text" class="value-input" id="scaleInput" value="1.5" style="display: none;">
                            <span class="value-display" id="scaleValue">1.50</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="scaleSlider" min="0.1" max="2.9" step="0.1" value="1.5">
                        </div>
                    </div>
                    <div class="control-group"> <!-- スライダー 2 -->
                        <div class="control-label">
                            <span class="label-text">⚡ V-Flex 縦-伸縮</span>
                            <input type="text" class="value-input" id="exponentialInput" value="0.0" style="display: none;">
                            <span class="value-display" id="exponentialValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="exponentialSlider" min="-0.5" max="0.5" step="0.01" value="0">
                        </div>
                    </div>
                    <div class="control-group"> <!-- スライダー 3 -->
                        <div class="control-label">
                            <span class="label-text">↕️ Up Down 上下</span>
                            <input type="text" class="value-input" id="pitchInput" value="0°" style="display: none;">
                            <span class="value-display" id="pitchValue">0.00°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="pitchSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <div class="control-group"> <!-- スライダー 4 -->
                        <div class="control-label">
                            <span class="label-text">↔️ Left Right 左右</span>
                            <input type="text" class="value-input" id="rollInput" value="0°" style="display: none;">
                            <span class="value-display" id="rollValue">0.00°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="rollSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <div class="control-group"> <!-- スライダー 5 -->
                        <div class="control-label">
                            <span class="label-text">🔄 Rotate 回転</span>
                            <input type="text" class="value-input" id="yawInput" value="0°" style="display: none;">
                            <span class="value-display" id="yawValue">0.00°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="yawSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <div class="control-group"> <!-- ★ スライダー 6: 2D画像回転（最後段） -->
                        <div class="control-label">
                            <span class="label-text">XY-rotate</span>
                            <input type="text" class="value-input" id="imgRotateInput" value="0°" style="display: none;">
                            <span class="value-display" id="imgRotateValue">0.00°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="imgRotateSlider" min="-180" max="180" step="1" value="0">
                        </div>
                    </div>
                     <!-- スライダー 7 但しPC（X/Yシフト：2Dの直前段） -->
                    <div class="control-group" id="centerXGroup" style="display: none;">
                        <div class="control-label">
                            <span class="label-text"> X-shift</span>
                            <input type="text" class="value-input" id="centerXInput" value="0.00" style="display: none;">
                            <span class="value-display" id="centerXValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="centerXSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <!-- スライダー 8 但しPC -->
                    <div class="control-group" id="centerYGroup" style="display: none;">
                        <div class="control-label">
                            <span class="label-text"> Y-shift</span>
                            <input type="text" class="value-input" id="centerYInput" value="0.00" style="display: none;">
                            <span class="value-display" id="centerYValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="centerYSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                
                    <!-- メニュー 1 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="editModeSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        🎚 Edit type
                        </label>
                        <select id="editModeSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="little_planet" style="background: #333; color: white;">Little Planet</option>
                            <option value="rabbit_hole" style="background: #333; color: white;">Rabbit Hole</option>
                        </select>
                    </div>
                    <!-- メニュー 2 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="formatSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        🎨 Format type
                        </label>
                        <select id="formatSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="jpeg" style="background: #333; color: white;">JPG 80%</option>
                            <option value="png" style="background: #333; color: white;">PNG</option>
                        </select>
                    </div>
                     <!-- メニュー 3 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="resolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        📐 Pixel size
                        </label>
                        <select id="resolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="512" style="background: #333; color: white;">512×512 (Preview)</option>
                            <option value="2048" style="background: #333; color: white;">2048×2048 (2K)</option>
                            <option value="4096" style="background: #333; color: white;">4096×4096 (4K)</option>
                        </select>
                    </div>
                    
                    <button class="download-btn" id="downloadBtn">📂 Download</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loadingText">Processing image...</div>
        </div>
    </div>

    <script>
        let originalImage = null;
        let workingImage = null;  // 編集用 1024x512
        let downloadImage = null; // ダウンロード用 4096x2048
        let isLittlePlanet = true;

        // 中心位置のオフセット（X/Yシフト：2D回転の直前段・見た目順では中間段）
        let centerOffsetX = 0;
        let centerOffsetY = 0;
                
                // 構図ガイドライン関連 20250811+
        let guidelineImages = {};
        const guidelineTypes = ['line01', 'line02', 'line03', 'line04', 'line05', 'line06'];
                
        window.addEventListener('load', function() {
                loadSampleImage();        
                loadGuidelineImages();// 20250811+
                // window.addEventListener('load'内に追加
                loadGuidelineImages();
                
                // イベントリスナー追加（DOM要素取得後）// 20250811+
                const guidelineSelect = document.getElementById('guidelineSelect');
                guidelineSelect.addEventListener('change', function() {
                render(); // for draw guideline
                
            });
            
            // リサイズ対応
            window.addEventListener('resize', function() {
                setTimeout(updateGuidelineSize, 100);
            });
            
            window.addEventListener('orientationchange', function() {
                setTimeout(updateGuidelineSize, 300);
            });
                        
            
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (!isTouchDevice) {
                document.getElementById('centerXGroup').style.display = 'block';
                document.getElementById('centerYGroup').style.display = 'block';
            }
        });

        function showLoading(text) {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.style.display = 'flex';
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = 'none';
        }

        function loadSampleImage() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Sample image loading skipped.');
                return;
            }
            const sampleImage = new Image();
            sampleImage.onload = function() {
                originalImage = sampleImage;
                createWorkingImages();
            };
            sampleImage.onerror = function() {
                console.log('sample4k.jpg is not available. select 360 image');
            };
            sampleImage.src = './sample4k.jpg';
        }
        
        // 構図ガイドライン画像の読み込み 20250811+
        function loadGuidelineImages() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Guideline images loading skipped.');
                return;
            }
        
            guidelineTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    guidelineImages[type] = img;
                    console.log(`Guideline image loaded: ${type}`);
                };
                img.onerror = function() {
                    console.log(`Guideline image not found: guidelines/${type}.png`);
                };
                img.src = `./guidelines/${type}.png`;
            });
        }

        function resetControlsAndSelectFile() {
            resetControls();
            document.getElementById('fileInput').click();
        }
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mainContent = document.getElementById('mainContent');
        const touchIndicator = document.getElementById('touchIndicator');

        const scaleSlider = document.getElementById('scaleSlider');
        const exponentialSlider = document.getElementById('exponentialSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const yawSlider = document.getElementById('yawSlider');
        const imgRotateSlider = document.getElementById('imgRotateSlider');
        const editModeSelect = document.getElementById('editModeSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const formatSelect = document.getElementById('formatSelect');

        const scaleValue = document.getElementById('scaleValue');
        const exponentialValue = document.getElementById('exponentialValue');
        const pitchValue = document.getElementById('pitchValue');
        const rollValue = document.getElementById('rollValue');
        const yawValue = document.getElementById('yawValue');
        const imgRotateValue = document.getElementById('imgRotateValue');
        const centerXValue = document.getElementById('centerXValue');
        const centerYValue = document.getElementById('centerYValue');

        const scaleInput = document.getElementById('scaleInput');
        const exponentialInput = document.getElementById('exponentialInput');
        const pitchInput = document.getElementById('pitchInput');
        const rollInput = document.getElementById('rollInput');
        const yawInput = document.getElementById('yawInput');
        const imgRotateInput = document.getElementById('imgRotateInput');
        const centerXInput = document.getElementById('centerXInput');
        const centerYInput = document.getElementById('centerYInput');

        const centerXSlider = document.getElementById('centerXSlider');
        const centerYSlider = document.getElementById('centerYSlider');

        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastPinchDistance = 0;
        let isPinching = false;
        let isMovingCenter = false;
        let tempScale = parseFloat(scaleSlider.value) || 1.5;
        let tempExponential = parseFloat(exponentialSlider.value);
        let tempPitch = parseFloat(pitchSlider.value);
        let tempRoll = parseFloat(rollSlider.value);
        let tempYaw = parseFloat(yawSlider.value);
        let tempImgRotate = parseFloat(imgRotateSlider.value) || 0;

        fileInput.addEventListener('change', handleFile);
        
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function() {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                resetControls();
                processFile(files[0]);
            }
        });

        function handleFile(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Choose image file!');
                return;
            }

            showLoading('Loading image...');

            const reader = new FileReader();
            reader.onload = function(e) {
                originalImage = new Image();
                originalImage.onload = function() {
                    console.log('Original image loaded: ' + originalImage.width + '×' + originalImage.height);
                    createWorkingImages();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createWorkingImages() {
            if (!originalImage) return;

            showLoading('Creating working images...');

            setTimeout(function() {
                const workingCanvas = document.createElement('canvas');
                const workingCtx = workingCanvas.getContext('2d');
                workingCanvas.width = 1024;
                workingCanvas.height = 512;
                
                workingCtx.drawImage(originalImage, 0, 0, 1024, 512);
                
                workingImage = new Image();
                workingImage.onload = function() {
                    console.log('Working image created: ' + workingImage.width + '×' + workingImage.height);
                    
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = 4096;
                    downloadCanvas.height = 2048;
                    
                    downloadCtx.drawImage(originalImage, 0, 0, 4096, 2048);
                    
                    downloadImage = new Image();
                    downloadImage.onload = function() {
                        console.log('Download image created: ' + downloadImage.width + '×' + downloadImage.height);
                        hideLoading();        
                        
                        mainContent.style.display = 'block';
                        render();
                    };
                    downloadImage.src = downloadCanvas.toDataURL();
                };
                workingImage.src = workingCanvas.toDataURL();
            }, 100);
        }

        function resetControls() {
            scaleSlider.value = '1.5';
            exponentialSlider.value = '0';
            pitchSlider.value = '0';
            rollSlider.value = '0';
            yawSlider.value = '0';
            imgRotateSlider.value = '0';
            scaleValue.textContent = '1.50';
            exponentialValue.textContent = '0.00';
            pitchValue.textContent = '0.00°';
            rollValue.textContent = '0.00°';
            yawValue.textContent = '0.00°';
            imgRotateValue.textContent = '0.00°';
            scaleInput.value = '1.50';
            exponentialInput.value = '0.00';
            pitchInput.value = '0.00';
            rollInput.value = '0.00';
            yawInput.value = '0.00';
            imgRotateInput.value = '0.00';
            tempScale = 1.5;
            tempExponential = 0;
            tempPitch = 0;
            tempRoll = 0;
            tempYaw = 0;
            tempImgRotate = 0;
            
            centerOffsetX = 0;
            centerOffsetY = 0;
            
            if (centerXSlider && centerYSlider) {
                centerXSlider.value = '0';
                centerYSlider.value = '0';
                centerXValue.textContent = '0.00';
                centerYValue.textContent = '0.00';
                centerXInput.value = '0.00';
                centerYInput.value = '0.00';
            }
            if (workingImage) {
                render();
            }
        }

        scaleSlider.addEventListener('input', function() {
            tempScale = parseFloat(scaleSlider.value);
            scaleValue.textContent = tempScale.toFixed(2);
            render();
        });

        exponentialSlider.addEventListener('input', function() {
            tempExponential = parseFloat(exponentialSlider.value);
            exponentialValue.textContent = tempExponential.toFixed(2);
            render();
        });

        pitchSlider.addEventListener('input', function() {
            tempPitch = parseFloat(pitchSlider.value);
            pitchValue.textContent = tempPitch.toFixed(2) + '°';
            render();
        });

        rollSlider.addEventListener('input', function() {
            tempRoll = parseFloat(rollSlider.value);
            rollValue.textContent = tempRoll.toFixed(2) + '°';
            render();
        });

        yawSlider.addEventListener('input', function() {
            tempYaw = parseFloat(yawSlider.value);
            yawValue.textContent = tempYaw.toFixed(2) + '°';
            render();
        });

        imgRotateSlider.addEventListener('input', function() {
            tempImgRotate = parseFloat(imgRotateSlider.value);
            imgRotateValue.textContent = tempImgRotate.toFixed(2) + '°';
            render();
        });

        if (centerXSlider && centerYSlider) {
            centerXSlider.addEventListener('input', function() {
                centerOffsetX = -parseFloat(centerXSlider.value);
                centerXValue.textContent = parseFloat(centerXSlider.value).toFixed(2);
                render();
            });
            centerYSlider.addEventListener('input', function() {
                centerOffsetY = parseFloat(centerYSlider.value);
                centerYValue.textContent = centerOffsetY.toFixed(2);
                render();
            });
        }

        editModeSelect.addEventListener('change', function() {
            const selectedMode = editModeSelect.value;
            isLittlePlanet = (selectedMode === 'little_planet');
            render();
        });

        scaleValue.addEventListener('click', function() { showInput(scaleValue, scaleInput, scaleSlider, false); });
        exponentialValue.addEventListener('click', function() { showInput(exponentialValue, exponentialInput, exponentialSlider, false); });
        pitchValue.addEventListener('click', function() { showInput(pitchValue, pitchInput, pitchSlider, true); });
        rollValue.addEventListener('click', function() { showInput(rollValue, rollInput, rollSlider, true); });
        yawValue.addEventListener('click', function() { showInput(yawValue, yawInput, yawSlider, true); });
        imgRotateValue.addEventListener('click', function() { showInput(imgRotateValue, imgRotateInput, imgRotateSlider, true); });

        if (centerXValue && centerYValue) {
            centerXValue.addEventListener('click', function() { showInput(centerXValue, centerXInput, centerXSlider, false); });
            centerYValue.addEventListener('click', function() { showInput(centerYValue, centerYInput, centerYSlider, false); });
        }

        function showInput(valueDisplay, input, slider, isDegree) {
            const currentValue = isDegree ? valueDisplay.textContent.replace('°', '') : valueDisplay.textContent;
            input.value = currentValue;
            valueDisplay.style.display = 'none';
            input.style.display = 'inline-block';
            input.focus();
            input.select();
        }

        function hideInput(input, valueDisplay, slider, isDegree) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            if (isDegree) {
                valueDisplay.textContent = newValue.toFixed(2) + '°';
                if (slider === pitchSlider) tempPitch = newValue;
                else if (slider === rollSlider) tempRoll = newValue;
                else if (slider === yawSlider) tempYaw = newValue;
                else if (slider === imgRotateSlider) tempImgRotate = newValue;
            } else {
                valueDisplay.textContent = newValue.toFixed(2);
                if (slider === scaleSlider) tempScale = newValue;
                else if (slider === exponentialSlider) tempExponential = newValue;
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            render();
        }

        const pitchInputEls = [scaleInput, exponentialInput, pitchInput, rollInput, yawInput, imgRotateInput];
        pitchInputEls.forEach(el => {
            el?.addEventListener('blur', function() {
                const map = new Map([
                    [scaleInput, [scaleValue, scaleSlider, false]],
                    [exponentialInput, [exponentialValue, exponentialSlider, false]],
                    [pitchInput, [pitchValue, pitchSlider, true]],
                    [rollInput, [rollValue, rollSlider, true]],
                    [yawInput, [yawValue, yawSlider, true]],
                    [imgRotateInput, [imgRotateValue, imgRotateSlider, true]]
                ]);
                const [v, s, d] = map.get(el);
                hideInput(el, v, s, d);
            });
            el?.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') el.blur();
            });
        });

        function hideInputCenter(input, valueDisplay, slider, axis) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            valueDisplay.textContent = newValue.toFixed(2);
            if (axis === 'X') {
                centerOffsetX = -newValue;
            } else if (axis === 'Y') {
                centerOffsetY = newValue;
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            render();
        }

        if (centerXInput && centerYInput) {
            centerXInput.addEventListener('blur', function() { hideInputCenter(centerXInput, centerXValue, centerXSlider, 'X'); });
            centerXInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') hideInputCenter(centerXInput, centerXValue, centerXSlider, 'X'); });
            centerYInput.addEventListener('blur', function() { hideInputCenter(centerYInput, centerYValue, centerYSlider, 'Y'); });
            centerYInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') hideInputCenter(centerYInput, centerYValue, centerYSlider, 'Y'); });
        }

        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        function normalizeAngle(angle, min, max) {
            const range = max - min;
            let normalized = angle % (range * 2);
            if (normalized > max) normalized -= range * 2;
            else if (normalized < min) normalized += range * 2;
            return Math.max(min, Math.min(max, normalized));
        }

        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                isPinching = false;
                isMovingCenter = false;
                tempPitch = parseFloat(pitchSlider.value);
                tempRoll = parseFloat(rollSlider.value);
                tempYaw = parseFloat(yawSlider.value);
            } else if (e.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                isMovingCenter = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                tempScale = parseFloat(scaleSlider.value);
            } else if (e.touches.length === 3) {
                isMovingCenter = true;
                isDragging = false;
                isPinching = false;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                touchIndicator.style.display = 'block';
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                tempRoll -= deltaX * 0.5;
                tempPitch += deltaY * 0.5;
                tempYaw -= deltaX * 0.5;

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                render();
            } else if (isPinching && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                const scaleChange = (currentDistance - lastPinchDistance) * 0.01;
                tempScale = Math.max(0.1, Math.min(3.9, tempScale + scaleChange));
                lastPinchDistance = currentDistance;
                render();
            } else if (isMovingCenter && e.touches.length === 3) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                centerOffsetX += deltaX * 0.005; // - 20250809
                centerOffsetY += deltaY * 0.005; // - 20250809

                centerOffsetX = Math.max(-1, Math.min(1, centerOffsetX));
                centerOffsetY = Math.max(-1, Math.min(1, centerOffsetY));

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                render();
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                tempYaw = normalizeAngle(tempYaw, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                yawSlider.value = tempYaw;
                pitchValue.textContent = tempPitch.toFixed(2) + '°';
                rollValue.textContent = tempRoll.toFixed(2) + '°';
                yawValue.textContent = tempYaw.toFixed(2) + '°';
                render();
            } else if (isPinching) {
                scaleSlider.value = tempScale;
                scaleValue.textContent = tempScale.toFixed(2);
                render();
            } else if (isMovingCenter) {
                touchIndicator.style.display = 'none';
            }
            isDragging = false;
            isPinching = false;
            isMovingCenter = false;
        }

        function handleMouseDown(e) {
            isDragging = true;
            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            tempPitch = parseFloat(pitchSlider.value);
            tempRoll = parseFloat(rollSlider.value);
            tempYaw = parseFloat(yawSlider.value);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - lastTouchX;
            const deltaY = e.clientY - lastTouchY;

            tempRoll -= deltaX * 0.5;
            tempPitch += deltaY * 0.5;
            tempYaw -= deltaX * 0.5;

            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            render();
        }

        function handleMouseUp(e) {
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                tempYaw = normalizeAngle(tempYaw, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                yawSlider.value = tempYaw;
                pitchValue.textContent = tempPitch.toFixed(2) + '°';
                rollValue.textContent = tempRoll.toFixed(2) + '°';
                yawValue.textContent = tempYaw.toFixed(2) + '°';
                render();
            }
            isDragging = false;
        }

        function sphericalToCartesian(theta, phi) {
            const x = Math.cos(phi) * Math.cos(theta);
            const y = Math.cos(phi) * Math.sin(theta);
            const z = Math.sin(phi);
            return [x, y, z];
        }

        function cartesianToSpherical(x, y, z) {
            const theta = Math.atan2(y, x);
            const phi = Math.asin(Math.max(-1, Math.min(1, z)));
            return [theta, phi];
        }

        function rotatePoint(x, y, z, pitch, roll, yaw) {
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            const cr = Math.cos(roll);
            const sr = Math.sin(roll);
            const cy = Math.cos(yaw);
            const sy = Math.sin(yaw);

            const rx = x * (cy * cr - sy * sp * sr) + y * (-sy * cp) + z * (cy * sr + sy * sp * cr);
            const ry = x * (sy * cr + cy * sp * sr) + y * (cy * cp) + z * (sy * sr - cy * sp * cr);
            const rz = x * (-cp * sr) + y * sp + z * (cp * cr);

            return [rx, ry, rz];
        }

        function render() {
            if (!workingImage) return;

            const scale = tempScale;
            const exponential = tempExponential;
            let pitch = (tempPitch * Math.PI) / 180;
            const roll = (tempRoll * Math.PI) / 180;
            const yaw = (tempYaw * Math.PI) / 180;
            const imgRot = (tempImgRotate * Math.PI) / 180; // 最後段

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            const size = 720;
            canvas.width = size;
            canvas.height = size;

            renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, workingImage);
            
            drawGuideline();

        }
        
        function drawGuideline() {
    const selectedType = document.getElementById('guidelineSelect').value;
    if (selectedType === 'none' || !guidelineImages[selectedType]) return;
    
    const guideline = guidelineImages[selectedType];
    
    // Canvas上に直接描画（位置ずれ完全解消）
    ctx.globalAlpha = 0.6; // 透明度設定
    ctx.drawImage(guideline, 0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1.0; // 透明度をリセット
}

        function renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, sourceImage) {
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = sourceImage.width;
            tempCanvas.height = sourceImage.height;
            tempCtx.drawImage(sourceImage, 0, 0);
            const sourceData = tempCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // 0) 出力座標を[-1,1]
                    const nx0 = (x / (size - 1)) * 2 - 1;
                    const ny0 = (y / (size - 1)) * 2 - 1;

                    // 1) まず 2D回転の逆変換（見た目では最後に回すため）
                    const rx =  nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    // 2) 次に X/Yシフトを打ち消す（見た目では直前段）
                    const nx = rx - centerOffsetX;
                    const ny = ry - centerOffsetY;

                    // 3) 以降は球面エフェクト
                    const r = Math.sqrt(nx * nx + ny * ny);
                    const angle = Math.atan2(ny, nx);
                    
                    let mappedR;
                    if (exponential === 0) {
                        mappedR = 2 * Math.atan(r * (4 - scale));
                    } else {
                        const atanComponent = 2 * Math.atan(r * (4 - scale));
                        const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
                        const blendFactor = Math.min(exponential / 3.0, 1.0);
                        mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
                    }
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll, yaw);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

                    const u = (spherical[0] + Math.PI) / (2 * Math.PI);
                    const v = (spherical[1] + Math.PI / 2) / Math.PI;

                    const imgX = Math.floor(u * sourceImage.width) % sourceImage.width;
                    const imgY = Math.floor(v * sourceImage.height) % sourceImage.height;

                    if (imgX >= 0 && imgX < sourceImage.width && imgY >= 0 && imgY < sourceImage.height) {
                        const sourceIndex = (imgY * sourceImage.width + imgX) * 4;
                        const targetIndex = (y * size + x) * 4;

                        data[targetIndex] = sourceData.data[sourceIndex];
                        data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                        data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                        data[targetIndex + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent);
        }

        function processImageInChunks(canvas, ctx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, currentY, callback) {
            const endY = Math.min(currentY + chunkSize, outputSize);
            const progress = Math.round((currentY / outputSize) * 100);
            document.getElementById('downloadBtn').textContent = '🔄 ' + progress + '%';

            if (!processImageInChunks.sourceData) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = downloadImage.width;
                tempCanvas.height = downloadImage.height;
                tempCtx.drawImage(downloadImage, 0, 0);
                processImageInChunks.sourceData = tempCtx.getImageData(0, 0, downloadImage.width, downloadImage.height);
            }

            const sourceData = processImageInChunks.sourceData;
            const chunkHeight = endY - currentY;
            const imageData = ctx.createImageData(outputSize, chunkHeight);
            const data = imageData.data;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < chunkHeight; y++) {
                for (let x = 0; x < outputSize; x++) {
                    const actualY = currentY + y;
                    const nx0 = (x / (outputSize - 1)) * 2 - 1;
                    const ny0 = (actualY / (outputSize - 1)) * 2 - 1;

                    // 1) 2D回転の逆
                    const rx =  nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    // 2) シフトの逆
                    const nx = rx - centerOffsetX;
                    const ny = ry - centerOffsetY;

                    // 3) 球面エフェクト
                    const r = Math.sqrt(nx * nx + ny * ny);
                    const angle = Math.atan2(ny, nx);
                    
                    let mappedR;
                    if (exponential === 0) {
                        mappedR = 2 * Math.atan(r * (4 - scale));
                    } else {
                        const atanComponent = 2 * Math.atan(r * (4 - scale));
                        const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
                        const blendFactor = Math.min(exponential / 3.0, 1.0);
                        mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
                    }
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll, yaw);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

                    const u = (spherical[0] + Math.PI) / (2 * Math.PI);
                    const v = (spherical[1] + Math.PI / 2) / Math.PI;

                    const imgX = Math.floor(u * downloadImage.width) % downloadImage.width;
                    const imgY = Math.floor(v * downloadImage.height) % downloadImage.height;

                    if (imgX >= 0 && imgX < downloadImage.width && imgY >= 0 && imgY < downloadImage.height) {
                        const sourceIndex = (imgY * downloadImage.width + imgX) * 4;
                        const targetIndex = (y * outputSize + x) * 4;

                        data[targetIndex] = sourceData.data[sourceIndex];
                        data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                        data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                        data[targetIndex + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, currentY);

            if (endY < outputSize) {
                setTimeout(function() {
                    processImageInChunks(canvas, ctx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, endY, callback);
                }, 10);
            } else {
                delete processImageInChunks.sourceData;
                callback();
            }
        }

        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (!downloadImage) return;

            const outputSize = parseInt(resolutionSelect.value);
            const outputFormat = formatSelect.value;
            const scale = parseFloat(scaleSlider.value);
            const exponential = parseFloat(exponentialSlider.value);
            let pitch = (parseFloat(pitchSlider.value) * Math.PI) / 180;
            const roll = (parseFloat(rollSlider.value) * Math.PI) / 180;
            const yaw = (parseFloat(yawSlider.value) * Math.PI) / 180;
            const imgRot = (parseFloat(imgRotateSlider.value) * Math.PI) / 180; // 最後段

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            const estimatedMemory = outputSize * outputSize * 4 * 3;
            const deviceMemory = navigator.deviceMemory || 2;
            
            if (outputSize >= 4096 && deviceMemory < 4) {
                if (!confirm('高解像度出力は大量のメモリを使用します。古い端末では動作が不安定になる可能性があります。続行しますか？')) {
                    return;
                }
            }

            console.log('Generating ' + outputSize + '×' + outputSize + ' image from download source ' + downloadImage.width + '×' + downloadImage.height + '...');

            const downloadBtn = document.getElementById('downloadBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = '🔄 Processing...';
            downloadBtn.disabled = true;

            let newWindow = null;
            if (isIOS()) {
                newWindow = window.open('about:blank', '_blank');
                if (!newWindow) {
                    alert('ポップアップがブロックされました。ブラウザの設定でポップアップを許可してください。');
                    downloadBtn.textContent = originalText;
                    downloadBtn.disabled = false;
                    return;
                }
                const countdownTime = outputSize >= 4096 ? 30 : 15;
                const resolutionText = outputSize === 2048 ? '2K' : outputSize === 4096 ? '4K' : 'preview';
                const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                const filename = modeText + '_' + resolutionText;
                
                newWindow.document.write('<!DOCTYPE html><html><head><title>' + filename + '</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body { margin: 0; padding: 20px; background: linear-gradient(135deg, #1e3c72, #2a5298); display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: white; } .spinner { width: 60px; height: 60px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 20px 0; } .back-btn { background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; margin: 20px 0; cursor: pointer; transition: background 0.3s; } .back-btn:hover { background: #0056CC; } .status-line { font-size: 20px; font-weight: bold; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style></head><body><div class="spinner"></div><button class="back-btn" onclick="window.close()">Return</button><div class="status-line" id="statusLine">Processing... ' + countdownTime + '</div></body></html>');
                
                let countdown = countdownTime;
                const statusElement = newWindow.document.getElementById('statusLine');
                const countdownInterval = setInterval(function() {
                    countdown--;
                    if (statusElement) {
                        if (countdown > 0) {
                            statusElement.textContent = 'Processing... ' + countdown;
                        } else {
                            statusElement.textContent = 'Processing...';
                            clearInterval(countdownInterval);
                        }
                    } else {
                        clearInterval(countdownInterval);
                    }
                }, 1000);
            }

            setTimeout(function() {
                try {
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = outputSize;
                    downloadCanvas.height = outputSize;

                    const chunkSize = outputSize >= 4096 ? 64 : outputSize >= 2048 ? 128 : 256;
                    
                    processImageInChunks(downloadCanvas, downloadCtx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, 0, function() {
                        const resolutionText = outputSize === 2048 ? '2K' : outputSize === 4096 ? '4K' : 'preview';
                        const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                        
                        const now = new Date();
                        const timestamp = now.getFullYear().toString() + 
                                        (now.getMonth() + 1).toString().padStart(2, '0') + 
                                        now.getDate().toString().padStart(2, '0') + '_' +
                                        now.getHours().toString().padStart(2, '0') + 
                                        now.getMinutes().toString().padStart(2, '0') + 
                                        now.getSeconds().toString().padStart(2, '0');
                        
                        let dataURL;
                        let fileExtension;
                        
                        if (outputFormat === 'jpeg') {
                            dataURL = downloadCanvas.toDataURL('image/jpeg', 0.8);
                            fileExtension = 'jpg';
                        } else {
                            dataURL = downloadCanvas.toDataURL('image/png');
                            fileExtension = 'png';
                        }
                        
                        const filename = modeText + '_' + resolutionText + '_exp' + exponential.toFixed(1) + '_imgRot' + (parseFloat(imgRotateSlider.value)||0).toFixed(0) + '_' + timestamp + '.' + fileExtension;

                        if (isIOS() && newWindow) {
                            const imgElement = newWindow.document.createElement('img');
                            imgElement.src = dataURL;
                            imgElement.alt = filename;
                            imgElement.style.cssText = 'width: min(90vw, 80vh); height: min(90vw, 80vh); object-fit: contain; border-radius: 10px; box-shadow: 0 4px 20px rgba(255,255,255,0.1); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px;';
                            
                            const instructionsDiv = newWindow.document.createElement('div');
                            instructionsDiv.innerHTML = 'Download or Share: Long press the image';
                            instructionsDiv.style.cssText = 'color: white; text-align: center; font-size: 16px; line-height: 1.5; position: absolute; top: calc(50% + min(45vw, 40vh) + 30px); left: 50%; transform: translateX(-50%); z-index: 1001;';
                            
                            const backBtn = newWindow.document.createElement('button');
                            backBtn.innerHTML = 'Return';
                            backBtn.onclick = function() { newWindow.close(); };
                            backBtn.style.cssText = 'background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background 0.3s; position: absolute; top: calc(50% + min(45vw, 40vh) + 80px); left: 50%; transform: translateX(-50%); z-index: 1001;';
                            backBtn.onmouseover = function() { this.style.background = '#0056CC'; };
                            backBtn.onmouseout = function() { this.style.background = '#007AFF'; };
                            
                            newWindow.document.body.appendChild(imgElement);
                            newWindow.document.body.appendChild(instructionsDiv);
                            newWindow.document.body.appendChild(backBtn);
                        } else if (!isIOS()) {
                            const link = document.createElement('a');
                            link.download = filename;
                            link.href = dataURL;
                            link.click();
                        }

                        downloadBtn.textContent = originalText;
                        downloadBtn.disabled = false;
                    });
                } catch (error) {
                    console.error('Download failed:', error);
                    alert('ダウンロードに失敗しました。メモリ不足の可能性があります。解像度を下げて再試行してください。');
                    if (newWindow) newWindow.close();
                    const downloadBtn = document.getElementById('downloadBtn');
                    downloadBtn.textContent = '📂 Download';
                    downloadBtn.disabled = false;
                }
            }, 100);
        });
    </script>
</body>
</html>
